# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()), который должен принимать данные (список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Примеры матриц: 3 на 2, 3 на 3, 2 на 4.
#
# 31    32         3    5    32        3    5    8    3
# 37    43         2    4    6         8    3    7    1
# 51    86        -1   64   -8
# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix (двух матриц). Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.
class Matrix:
    def __init__(self, matrix):
        self.m = matrix

    def __str__(self):
        for i in range(len(self.m)):
            for j in range(len(self.m[i])):
                print(self.m[i][j], end = ' ')
            print('')

    def __add__(self, other):
        for i in range(len(self.m)):
            for j in range(len(self.m[i])):
                try:
                    el = self.m[i][j] + other.m[i][j]
                    print(el, end = ' ')
                except IndexError:
                    pass
            print()

m1 = Matrix([[31, 32], [37, 43], [51, 86]])
m2 = Matrix([[3, 5, 32], [2, 4, 6], [-1, 64, -8]])
m3 = Matrix([[3, 5, 8, 3], [8, 3, 7, 1]])

m1.__str__()
print()
m2.__str__()
print()
m3.__str__()
print()
m1 + m2
print()
m1 + m3
print()
m2 + m3

# 2. Реализовать проект расчёта суммарного расхода ткани на производство одежды. Основная сущность (класс) этого проекта — одежда, которая может иметь определённое название. К типам одежды в этом проекте относятся пальто и костюм. У этих типов одежды существуют параметры: размер (для пальто) и рост (для костюма). Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5), для костюма (2*H + 0.3). Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке знания: реализовать абстрактные классы для основных классов проекта, проверить на практике работу декоратора @property.

class Clothes:
    def __init__(self, name):
        self.n = name

    def __add__(self, other):
        f_t = self + other
        print(f'Общий расход для пошива составит {round((f_t), 2)} м.')
        #print(f'Общий расход для пошива {self.n} составит {round((f_t), 2)} м.') #почему нельзя сделать такой вывод?


class Coat(Clothes):
    def __init__(self, name, size):
        Clothes.__init__(self, name)
        self.s = size

    @property
    def materials(self):
        f_s = self.s/6.6 + 0.5
        print(f' Для {self.n} понадобится  {round(f_s, 2)} м ткани.')
        return f_s

    @materials.setter   #валидация не сработала,почему не знаю, на вебинаре так и не разобрались в чем ошибка была
    def materials(self, f_s):
        if f_s > 0.5 and f_s < 1:
            self.f_s = 1
        else:
            self.f_s = f_s



class Suit(Clothes):
    def __init__(self, name,  height):
        Clothes.__init__(self, name)
        self.h = height
    @property
    def materials(self):
        f_s = 2*self.h + 0.5
        print(f' Для {self.n} понадобится  {f_s} м ткани.')
        return f_s

    @materials.setter    #валидация не сработала,почему не знаю
    def materials(self, f_s):
        if f_s > 0.5 and f_s < 1:
            self.f_s = 1
        else:
            self.f_s = f_s


C = Clothes('Верхняя одежда')

C1 = Coat('Пальто', 2.7)
#C1.materials

C2 = Suit('Костюм', 1.9)
#C2.materials

Clothes.__add__(self = C1.materials, other = C2.materials)  #как вызвать метод без присвоения параметров self и other при вызове?

# Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо
# создать класс Клетка. В его конструкторе инициализировать параметр, соответствующий
# количеству ячеек клетки (целое число). В классе должны быть реализованы методы
# © geekbrains.ru 20
# перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()),
# умножение (__mul__()), деление (__truediv__()). Данные методы должны применяться только
# к клеткам и выполнять увеличение, уменьшение, умножение и целочисленное (с округлением
# до целого) деление клеток, соответственно.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться
# сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность
# количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как
# произведение количества ячеек этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как
# целочисленное деление количества ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и
# количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n
# равно переданному аргументу. Если ячеек на формирование ряда не хватает, то в последний
# ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод
# make_order() вернет строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод
# make_order() вернет строку: *****\n*****\n*****.
#
class Square:

    def __init__(self, q_cell):
        self.q_cell = q_cell

    def __add__(self, other):
        return Square(self.q_cell + other.q_cell)

    def __sub__(self, other):
        sub_res = self.q_cell - other.q_cell
        if sub_res >= 0:
            print(f'Разность ячеек равна {sub_res}.')
        else:
            print('Невозмжно выполнить операцию.')

    def __mul__(self, other):
        return Square(self.q_cell * other.q_cell)

    def __truediv__(self, other):
        try:
            tr_res = self.q_cell // other.q_cell
            if tr_res < 1:
                print('Числитель меньше знаменателя')
            else:
                print(tr_res)
        except ZeroDivisionError:
            print('На ноль делить нельзя')

    def make_order(self, raw = 3):
        self.r = raw
        m_o = self.q_cell // raw
        m_p = self.q_cell % raw
        p = '*'
        for el in range(m_o): #не сообразила как в одну строку записать вывод ***\n***\n**
            print(p*raw)
        print(p*m_p)




q_cell1 = Square(10)
q_cell12 = Square(1)
q_cell13 = Square(0)
q_cell1.make_order()
q_cell12.make_order()
q_cell12/q_cell1
q_cell12/q_cell13
q_sum = q_cell1 + q_cell12 + q_cell13
print(q_sum.q_cell)
q_cell12 - q_cell1
q_cell12 - q_cell12
q_cell13 - q_cell12
q_mul = q_cell13 * q_cell12 * q_cell1
print(q_mul.q_cell)






